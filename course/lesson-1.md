
# Structure of a Rust Project

A Rust project created using Cargo follows a standard directory structure.

```mermaid
flowchart TD
    A[deck/] --> B[Cargo.toml]
    A --> C[Cargo.lock]
    A --> D[src/]
    D --> E[main.rs]
    A --> F[target/]


````

After running the project, two additional items are generated:
- `Cargo.lock`
- `target/` folder

These are created automatically after running:

```bash
cargo run -q
````

---

## Cargo.toml

`Cargo.toml` is the **configuration file** for a Rust project.
It contains metadata and dependency information.

```toml
[package]
name = "deck"
version = "0.1.0"
edition = "2024"

[dependencies]
```

* `name` → Project name
* `version` → Project version
* `edition` → Rust edition being used
* `[dependencies]` → External crates (libraries) used in the project

---

## main.rs

`main.rs` is the **entry point** of a Rust binary application.

```rust
fn main() {
    println!("Hello, world!");
}
```

Execution starts from the `main()` function.

---

## Cargo.lock and target Folder

* `Cargo.lock`

  * Records exact versions of dependencies
  * Ensures reproducible builds
  * Automatically generated by Cargo

* `target/`

  * Contains compiled binaries
  * Stores build artifacts
  * Safe to delete (will be recreated)

---

## Structs in Rust

Structs in Rust are **similar to classes**, but:

* They do not contain inheritance
* Behavior is added using `impl` blocks

---

### Defining a Struct

```rust
struct Deck {
    cards: Vec<String>,
}
```

* `Deck` → Struct name
* `cards` → Field name
* `Vec<String>` → Vector holding card values

---

## Vectors (`Vec`)

* Vectors are **dynamic arrays**
* They do **not** have a fixed length
* They can grow or shrink at runtime

---

## Using a Struct

### Creating a Struct Instance (Using `vec![]`)

```rust
struct Deck {
    cards: Vec<String>,
}

fn main() {
    // Variable to store struct
    let my_deck = Deck { cards: vec![] };
    println!("Hello, world!");
}
```

---

### Creating a Struct Instance (Using `Vec::new()`)

```rust
struct Deck {
    cards: Vec<String>,
}

fn main() {
    // Variable to store struct
    let my_deck = Deck { cards: Vec::new() };
    println!("Hello, world!");
}
```

Both approaches are valid:

* `vec![]` → Macro-based initialization
* `Vec::new()` → Function-based initialization

---

## Key Takeaways

* Cargo enforces a clean, predictable project structure
* `Cargo.toml` defines project metadata and dependencies
* `main.rs` is the execution entry point
* Structs group related data
* `Vec<T>` provides flexible, dynamic storage
* Cargo automatically manages build artifacts and lock files

